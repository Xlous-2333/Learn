# **Python**语言

1，高效的高级数据结构

2，面向对象编程

3，解释型语言

“基于C语言，ABC语言，Modula-3语言，无指针，语言风格严格缩进，同时有继承自Modula-3的异常处理、模块系统、关键字参数等”

Python 1.0 函数式编程

Python 2.0 迭代器、生成器、列表推导式、垃圾回收等

Python 3.0 至今(无法向下兼容，Python 2的程序可能无法在Python 3下正常运行)

特点：

​	简单易学：

​	简洁优美：

​	面向对象：

​	交互模式：

​	开源可移植：

​	可拓展性：

​	多范式的编程语言：



## 字符串:

```python
# 字符串：一串由Unicode码位值组成的序列，可使用一对“"”或一对“'”来定义
# Python没有char类型；而是将字符串中的每个码位表示为一个长度为1的字符串对象
# 字符串可以使用\"或者\'做字符串转义，但是在开发中若字符串内部需要使用“"”，可使用“'”来定义字符串，反之亦然
# 对于字符串可使用"r"取消转义
# ord() 可将一个码位由字符串形式转换成一个范围在 0 - 10FFFF 之内的整型数
# chr() 可将一个范围在 0 - 10FFFF 之内的整型数转换为长度为 1 的对应字符串对象
# str.encode() 可以使用指定的文本编码将 str 转换为 bytes
# bytes.decode() 可以解码
# 字符串可通过索引取串中字符，从0开始
# len(字符串)：获取字符串长度
# 字符串.count(字符串)：小字符串在大字符串中出现的次数
# 字符串[m: n: x]：切片取值，取下标为m到n-1步长为x的字符串，留空默认全取到
# string.isspace()：若string中只包含空格，则返回True
# string.isalnum()：若string至少有一个字符并且所有字符都是字母或数字，则返回True
# string.isalpha()：若string至少有一个字符并且所有字符都是字母，则返回True
# string.isdecimal()：若string只包含数字(全角数字)，则返回True
# string.isdigit()：若string只包含数字(全角数字、{1}、、u00b2)，则返回True
# string.isnumeric()：若string只包含数字(全角数字、汉字数字)，则返回True
# string.istitle()：若string是标题化的(每个单词都是首字母大写的)，则返回True
# string.islower()：若string包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回True
# string.isupper()：若string包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回True
# string.capitalize()：获得首字母大写后的字符串
# string.title()：获得每个单词首字母大写后的字符串
# string.upper()：获得字符串大写后的字符串
# string.lower()：获得字符串小写后的字符串
# string.find(字符串)：从字符串中查找另一个字符串所在的位置后返回字符串首字符索引，没找到返回-1,可以设置参数限定范围
# string.index(字符串)：从字符串中查找另一个字符串所在的位置后返回字符串首字符索引，没找到引发异常，可以设置参数限定范围
# string.rfind(字符串)：从后向前在字符串中查找另一个字符串所在的位置后返回字符串首字符索引
# string.startswith(字符串)：判断字符串是否以指定字符串开头
# string.endswith(字符串)：判断字符串是否以指定字符串结尾
# string.isdigit()：判断字符串是否由数字构成
# string.isalpha()：判断字符串是否由字母构成
# string.isalnum()：判断字符串是否由数字和字母构成
# string.center(n, 字符)：以宽度为n将字符串居中并在两侧填充字符
# string.rjust(n)：以宽度n将字符串右对齐并在左侧填充空格
# string.ljust(n, 字符)：以宽度n将字符串左对齐并在右侧填充字符
# string.zfill(n)：在字符串的左侧补0(使之总宽度为n)
# string.split('*'):通过字符'*'对字符串进行分割，以列表形式返回，参数留空默认以' '(空格)分割
# 字符.join(list):以字符为连接值连接list为一个字符串
```



## 进制转换:

```python
a = 0b1101  # 二进制数字
b = 0o123  # 八进制数字
c = 8  # 十进制数字
d = 0x09192  # 十六进制数字
f = 13.14 # 浮点数
```

```python
# print(bin(n))  # 将数字n转化为二进制数字
# print(oct(n))  # 将数字n转化为八进制数字
print(f.hex())  # 返回以十六进制字符串表示的浮点数f，包含前导的0x和尾随的p加指数
# print(n.bit_length())  # 返回以二进制表示一个整数需要的位数，不包括符号位和前面的0
# print(n.bit_count())  # 返回整数的绝对值的二进制表示中1的个数
p = d.to_bytes(d.bit_length(), byteorder='little', signed=True) # 返回表示整数d的一个字节数组，使用d.bit_length()个字节，big让最高位字节放在字节数组的开头，little让最高位字节放在字节数组的末尾，signed参数确定是否用二的补码来表示整数，默认为False
float.fromhex('0x3.a7p10')  # 返回以十六进制字符串'0x3.a7p10'表示的浮点数
# 注意：hex()是实例方法，而float.from(s)是类方法
```



## 内置方法及使用，查找的方法，关键字:

```python
代码：
	dir(__builtins__):查看内置方法
运行结果：
['ArithmeticError', 'AssertionError', 'AttributeError', 'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError', 'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError', 'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError', 'DeprecationWarning', 'EOFError', 'Ellipsis', 'EncodingWarning', 'EnvironmentError', 'Exception', 'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError', 'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning', 'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError', 'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'ModuleNotFoundError', 'NameError', 'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError', 'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError', 'ProcessLookupError', 'RecursionError', 'ReferenceError', 'ResourceWarning', 'RuntimeError', 'RuntimeWarning', 'StopAsyncIteration', 'StopIteration', 'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError', 'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError', 'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning', 'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '__build_class__', '__debug__', '__doc__', '__import__', '__loader__', '__name__', '__package__', '__spec__', 'abs', 'aiter', 'all', 'anext', 'any', 'ascii', 'bin', 'bool', 'breakpoint', 'bytearray', 'bytes', 'callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec', 'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance', 'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max', 'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print', 'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr', 'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type', 'vars', 'zip']
```

OS模块官方文档：https://docs.python.org/zh-cn/3/library/os.html

Requests模块官方文档：https://docs.python-requests.org/zh_CN/latest/user/quickstart.html

Beautiful Soup模块官方文档：https://beautifulsoup.readthedocs.io/zh_CN/v4.4.0/

日历模块官方文档：https://docs.python.org/zh-cn/3/library/calendar.html

time模块官方文档：https://docs.python.org/zh-cn/3/library/time.html

datetime模块官方文档：https://docs.python.org/zh-cn/3/library/datetime.html





```python
查看方法的说明：
1：help(方法名)
2：print(方法名.__doc__)
```

```python
查看关键字：
	import keyword
	print(keyword.kwlist)
运行结果：
['False','None','True','and','as','assert','async','await','break','class','continue','def','del','elif','else','except','finally','for','from','global','if','import','in','is','lambda','nonlocal','not','or','pass','raise','return','try','while','with','yield']
```



## type查看类型:

```python
代码：
    a = 10
    b = '20'
    print(type(a))
    print(type(b))
运行结果：
	<class 'int'>
	<class 'str'>
```



## 类型说明：

```python
iterable:可迭代对象，字符串、元组、列表、字典、集合都是可迭代对象
		 数字不是可迭代对象
不可变数据类型：字符串、元组
可变数据类型：列表、字典、集合
```



## 类：

```python
__new__(cls, ···)：创建对象，cls指向类本身，返回对象
__slots__：允许绑定的属性(以元组的形式赋给)
__init__：初始化参数(创建完对象之后)
__repr__:
super()：父类同名方法
__del__(self):使用del删除对象时进行的方法

callable(·)：Python内置函数：判断对象是否时可调用对象(默认情况类的实例时不可调用对象)
__cell__：定义该方法后，实例就是可调用对象了

装饰器：将函数作为参数/返回值的函数/@
functools.wraps(func)
property：使实例的方法编程属性/调用此方法时不必加括号
property.setter:修改其值
property.deleter:删除实例的某属性
classmethod：创建类方法(无需创建实例，直接使用类来调用类方法即可)，其装饰的方法第一个参数时cls，类对象
staticmethod：创建静态方法，类/类的实例均可调用，不需要传入cls
```

疑惑：类中的一个属性(没有写在init中的)为何不能直接在类中调用

​			多继承时如何使用继承的某个类？解答：（mro()方法查看类的解析顺序)

| 特殊方法    | 用途                       |
| ----------- | -------------------------- |
| `__init__`  | 构造方法，初始化实例       |
| `__repr__`  | 格式化实例的打印样式       |
| `__new__`   | 创建实例时执行             |
| `__del__`   | 析构方法，在删除时会被调用 |
| `__slots__` | 限制绑定属性               |
| `__call__`  | 使实例变成可调用对象       |
| ``          |                            |

## Python高阶函数：

| 函数名   | 描述                                                         | 示例                   |
| :------- | ------------------------------------------------------------ | ---------------------- |
| `sorted` | 返回完成排序后的列表，不改动原列表，可接受函数，可选参数: `key=` 表示根据自定义参数排序 | `sorted(list, key=**)` |
| `filter` | 对序列进行过滤，返回符合过滤条件的序列(迭代器对象)，对第二个参数中的元素判断，通过则保留 | `filter(条件, 数据)`   |
| `map`    | 依照第一参数的方法处理第二参数中的元素并返回(迭代器对象)     | `map(函数, 数据)`      |
| `lambda` | 匿名函数，必须要有参数(1/多)，只能有一个表达式               | `lambda 参数 : 表达式` |
|          |                                                              |                        |

`reduce`：需要从`functools`模块导入该函数，`reduce(a, b)`表示用a函数来处理b，与map类似，但reduce是对b做积累处理，如累加求和：`reduce(a, b)  a(x,y):return x+y  b = [1, -2, 3]`

### 部分内置函数：

| 函数名                   | 描述                                         | 示例                            |
| ------------------------ | -------------------------------------------- | ------------------------------- |
| `abs`                    | 获取数字的绝对值                             | `abs(3.14)`                     |
| `isinstance(数据, 类型)` | 判断数据的数据类型，返回是否匹配(True/False) | `isinstance(2.2， float)`->True |
|                          |                                              |                                 |
|                          |                                              |                                 |







# 正则表达式(re):

正则表达式是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为"元字符"），描述了一种字符串匹配的模式。

正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。

## 普通字符

​	**普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。**

`[ABC]`：匹配 [...] 中的所有字符，例如` [aeiou] `匹配字符串 "google runoob taobao" 中所有的 e o u a 字母。

`[^ABC]`：匹配除了 [...] 中字符的所有字符，例如` [^aeiou] `匹配字符串 "google runoob taobao" 中除了 e o u a 字母的所有字母。

 `[A-Z]` ：表示一个区间，匹配所有大写字母，`[a-z]` 表示所有小写字母。

`.`：匹配除换行符(\n、\r)之外的任何单个字符，相等于 `[^\n\r]`。

`[\s\S]`：匹配所有。`\s`是匹配所有空白符，包括换行，`\S`非空白符，不包括换行。

`\w`：匹配字母、数字、下划线。等价于`[A-Za-z0-9_]`

## 非打印字符

​	**非打印字符也可以是正则表达式的组成部分**

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| \cx  | 匹配由x指明的控制字符。例如，`\cM`匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。 |
| \f   | 匹配一个换页符。等价于`\x0c`和`\cL`。                        |
| \n   | 匹配一个换行符。等价于`\x0a`和`\cJ`。                        |
| \r   | 匹配一个回车符。等价于`\x0d`和`\cM`。                        |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于`[ \f\n\r\t\v]`。注意 Unicode 正则表达式会匹配全角空格符。 |
| \S   | 匹配任何非空白字符。等价于`[^ \f\n\r\t\v]`。                 |
| \t   | 匹配一个制表符。等价于`\x09`和`\cI`。                        |
| \v   | 匹配一个垂直制表符。等价于`\x0b`和`\cK`。                    |

## 特殊字符

所谓特殊字符，就是一些有特殊含义的字符，如上面说的`runoo\*b`中的`*`，简单的说就是表示任何字符串的意思。如果要查找字符串中的`*`符号，则需要对`*`进行转义，即在其前加一个`\`，`runo\*ob` 匹配字符串`runo\*ob`。许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符"转义"，即，将反斜杠字符`\`放在它们前面。

| 特别字符 | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| $        | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。 |
| ( )      | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 |
| *        | 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \*。     |
| +        | 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \+。     |
| .        | 匹配除换行符 \n 之外的任何单字符。要匹配 . ，请使用 \. 。    |
| [        | 标记一个中括号表达式的开始。要匹配 [，请使用 \[。            |
| ?        | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
| \        | 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。 |
| ^        | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
| {        | 标记限定符表达式的开始。要匹配 {，请使用 \{。                |
| \|       | 指明两项之间的一个选择。要匹配 \|，请使用 \|。               |

## 限定符

​	**限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 `*` 或 `+` 或 `?` 或`{n}`或`{n,}`或 `{n,m}`共6种。**

| 限定符 | 描述                                                         |
| :----- | :----------------------------------------------------------- |
| *      | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。 |
| +      | 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。 |
| ?      | 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 、 "does" 中的 "does" 、 "doxy" 中的 "do" 。? 等价于 {0,1}。 |
| {n}    | n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 "Bob" 中的 'o'，但是能匹配 "food" 中的两个 o。 |
| {n,}   | n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 "Bob" 中的 'o'，但能匹配 "foooood" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 |
| {n,m}  | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，"o{1,3}" 将匹配 "fooooood" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 |

## 定位符

定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。

定位符用来描述字符串或单词的边界，`^` 和 `$` 分别指字符串的开始与结束，`\b` 描述单词的前或后边界，`\B` 表示非单词边界。

正则表达式的定位符有：

| 字符 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| ^    | 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。 |
| $    | 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。 |
| \b   | 匹配一个单词边界，即字与空格间的位置。                       |
| \B   | 非单词边界匹配。                                             |

**注意**：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 `^\*` 之类的表达式。

若要匹配一行文本开始处的文本，请在正则表达式的开始使用 `^` 字符。不要将 `^` 的这种用法与中括号表达式内的用法混淆。

若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 `$` 字符。

## 选择

用圆括号 `()` 将所有选择项括起来，相邻的选择项之间用 `|` 分隔。

​	`()` 表示捕获分组，`()` 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(`n` 是一个数字，表示第 n 个捕获组的内容)。

用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用 **?:** 放在第一个选项前来消除这种副作用。

​	其中 **?:** 是非捕获元之一，还有两个非捕获元是 **?=** 和 **?!**，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。

## 反向引用

对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 `\n` 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。

可以使用非捕获元字符 `?:`、`?=` 或 `?!` 来重写捕获，忽略对相关匹配的保存。

反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。



# JSON：

JSON模块官方文档：https://docs.python.org/zh-cn/3/library/json.html



## 在Python中如何理解对象？

​    Python中，定义是松散的，某些对象既没有属性也没有方法，而且不是所有的对象都可以子类化。在Python中万物皆对象，即Python 中的一切都可以赋值给变量或者作为参数传递给函数。

Python 的所有对象都有三个特性：

​	身份：每个对象都有一个唯一的身份标识自己，任何对象的身份都可以使用内建函数 id() 来得到，可以简单的认为这个值是该对象的内存地址。

​	类型：对象的类型决定了对象可以保存什么类型的值，有哪些属性和方法，可以进行哪些操作，遵循怎样的规则。可以使用内建函数 type() 来查看对象的类型。

​	值：对象所表示的数据。

"身份"、"类型"和"值"在所有对象创建时被赋值。如果对象支持更新操作，则它的值是可变的，否则为只读(数字、字符串、元组等均不可变)。只要对象还存在，这三个特性就一直存在。

对象的属性：大部分 Python 对象有属性、值或方法，使用句点(.)标记法来访问属性。最常见的属性是函数和方法，一些 Python 对象也有数据属性，如：类、模块、文件等。



## 类和对象有什么分别？

1、类和对象得区别：类是对客观世界中事物得抽象，而对象是类实例化后的实体

- 类是对现实生活中一类具有共同属性和行为的事物的抽象

- 类是对象的数据类型，类是具有相同属性和行为的一组对象的集合

  **类是对事物的一种描述，对象则为具体存在的事物**

2、类的定义：

​	（1）python使用class关键字定义一个类，类名的首字母一般要大写：

​	（2）类的主体由一系列的属性和方法组成

3、对象的创建：

  创建对象的过程称为实例化，当一个对象被创建后，包含3个方面的特性：对象的句柄、属性和方法

  对象的句柄：用于区分不同的对象



## `__init__`和`__new__`有什么区别？

继承自object的新式类才有`__new__`

`__new__`至少要有一个参数`cls`，代表当前类，此参数在实例化时由Python解释器自动识别

`__new__`必须要有返回值，返回实例化出来的实例，这点在自己实现`__new__`时要特别注意，可以return父类（通过`super(当前类名, cls)`）`__new__`出来的实例，或者直接是object的`__new__`出来的实例

`__init__`有一个参数self，就是这个`__new__`返回的实例，`__init__`在`__new__`的基础上可以完成一些其它初始化的动作，`__init__`不需要返回值

如果`__new__`创建的是当前类的实例，会自动调用`__init__`函数，通过return语句里面调用的`__new__`函数的第一个参数是`cls`来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的`__init__`函数，也不会调用其他类的`__init__`函数。

`__new__`方法主要是当你继承一些不可变的class时(比如`int, str, tuple`)， 提供给你一个自定义这些类的实例化过程的途径。

1、在定义子类时没有重新定义`__new__()`时，Python默认是调用该类的直接父类的`__new__()`方法来构造该类的实例，如果该类的父类也没有重写`__new__()`，那么将一直按此规矩追溯至object的`__new__()`方法，因为object是所有新式类的基类。

2、而如果子类中重写了`__new__()`方法，那么你可以自由选择任意一个的其他的新式类（必定要是新式类，只有新式类必定都有`__new__()`，因为所有新式类都是object的后代，而经典类则没有`__new__()`方法）的`__new__()`方法来制造实例，包括这个新式类的所有前代类和后代类，只要它们不会造成递归死循环。反正肯定不能调用自己的`__new__`，这肯定是死循环。

3、对于子类的`__init__`，其调用规则跟`__new__`是一致的，当然如果子类和父类的`__init__`函数都想调用，可以在子类的`__init__`函数中加入对父类`__init__`函数的调用。

4、我们在使用时，尽量使用`__init__`函数，不要去自定义`__new__`函数，因为这两者在继承派生时的特性还是很不一样的。

## 三次握手和四次挥手

![img](https://pics3.baidu.com/feed/64380cd7912397ddb480a4110c5c4ab2d1a28709.jpeg?token=45d9d76830f1e8052a5f5394378e459a&s=048A5F31C60E77495EC7C14D0300C0E2)

Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。

Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。

URG：紧急指针（urgent pointer）有效。

ACK：确认序号有效。

PSH：接收方应该尽快将这个报文交给应用层。

RST：重置连接。

SYN：发起一个新连接。

FIN：释放一个连接。

![img](https://pics1.baidu.com/feed/d8f9d72a6059252d20d93b0a6645fb3e59b5b9d2.jpeg?token=c86d4509157378798ebbccbe843486d1&s=9746F8123F5754CA48D574DA0300D0B2)

握手之前主动打开连接的客户端结束CLOSED阶段，被动打开的服务器端也结束CLOSED阶段，并进入LISTEN阶段。随后开始“三次握手”：

（1）首先客户端向服务器端发送一段TCP报文，其中：

​	标记位为SYN，表示“请求建立新连接”；

​	序号为Seq=X（X一般为1）；

​	随后客户端进入SYN-SENT阶段。

（2）服务器端接收到来自客户端的TCP报文之后，结束LISTEN阶段。并返回一段TCP报文，其中：

​	标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；

​	序号为Seq=y；

​	确认号为Ack=x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值；

​	随后服务器端进入SYN-RCVD阶段。

（3）客户端接收到来自服务器端的确认收到数据的TCP报文之后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段。并返回最后一段TCP报文。其中：

​	标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；

​	序号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；

​	确认号为Ack=y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；

​	随后客户端进入ESTABLISHED阶段。

服务器收到来自客户端的“确认收到服务器数据”的TCP报文之后，明确了从服务器到客户端的数据传输是正常的。结束SYN-SENT阶段，进入ESTABLISHED阶段。

在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性。一旦出现某一方发出的TCP报文丢失，便无法继续"握手"，以此确保了"三次握手"的顺利完成。

### **为什么要进行第三次握手？**

为了防止服务器端开启一些无用的连接增加服务器开销以及防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1创建连接的请求(第一次握手)。

如果服务器端就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。

客户端可能设置了一个超时时间，时间到了就关闭了连接创建的请求。再重新发出创建连接的请求，而服务器端是不知道的，如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，

服务器端是不知道客户端有没有接收到服务器端返回的信息的。没有给服务器端一个创建还是关闭连接端口的请求，服务器端的端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。那么服务器端上没有接收到请求数据的上一个端口就一直开着，长此以往，这样的端口多了，就会造成服务器端开销的严重浪费。

还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。

所以我们需要“第三次握手”来确认这个过程，让客户端和服务器端能够及时地察觉到因为网络等一些问题导致的连接创建失败，这样服务器端的端口就可以关闭了不用一直等待。

![img](https://pics5.baidu.com/feed/48540923dd54564e5260495ce0006487d0584fb6.jpeg?token=c3a743af38e25ff66deb6a07891be58e&s=C584FC1A71CFF4EE1A75A45203007073)

挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”：

（1）首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：

​	标记位为FIN，表示“请求释放连接“；

​	序号为Seq=U；

随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。

注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。

（2）服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：

​	标记位为ACK，表示“接收到客户端发送的释放连接的请求”；

​	序号为Seq=V；

​	确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；

随后服务器端开始准备释放服务器端到客户端方向上的连接。客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段

前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了

（3）服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：

​	标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到服务器端报文的确认报文。

​	序号为Seq=W；

​	确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。

随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。

（4）客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：

​	标记位为ACK，表示“接收到服务器准备好释放连接的信号”。

​	序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。

​	确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。随后客户端开始在TIME-WAIT阶段等待2MSL

服务器端收到从客户端发出的TCP报文之后结束LAST-ACK阶段，进入CLOSED阶段。由此正式确认关闭服务器端到客户端方向上的连接。

客户端等待完2MSL之后，结束TIME-WAIT阶段，进入CLOSED阶段，由此完成“四次挥手”。

后“两次挥手”既让客户端知道了服务器端准备好释放连接了，也让服务器端知道了客户端了解了自己准备好释放连接了。于是，可以确认关闭服务器端到客户端方向上的连接了，由此完成“四次挥手”。

在客户端与服务器端传输的TCP报文中，双方的确认号Ack和序号Seq的值，都是在彼此Ack和Seq值的基础上进行计算的，这样做保证了TCP报文传输的连贯性，一旦出现某一方发出的TCP报文丢失，便无法继续"挥手"，以此确保了"四次挥手"的顺利完成。

### **为什么“握手”是三次，“挥手”却要四次？**

TCP建立连接时之所以只需要"三次握手"，是因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。

即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。

TCP释放连接时之所以需要“四次挥手”,是因为FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的。为何建立连接时一起传输，释放连接时却要分开传输？

建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文。

所以是“三次握手”，“四次挥手”。

### **为什么要客户端在TIME-WAIT阶段要等待2MSL呢？**

为的是确认服务器端是否收到客户端发出的ACK确认报文

当客户端发出最后的ACK确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完ACK确认报文之后，会设置一个时长为2MSL的计时器。MSL指的是Maximum Segment Lifetime：一段TCP报文在传输过程中的最大生命周期。2MSL即是服务器端发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

服务器端在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文；

​	如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时；否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSED阶段，完成“四次挥手”。

所以，客户端要经历时长为2MSL的TIME-WAIT阶段；

